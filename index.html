<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filtre de Kalman Avancé - Suivi de Drone</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        :root {
            --background: #0A0E1A;
            --panel: #1A1F2E;
            --card: #232938;
            --border: #374151;
            --grid: #2D3748;
            --text: #E8EAED;
            --text-secondary: #9AA0A6;
            --accent: #4A9EFF;
            --warning: #FFB020;
            --error: #FF4757;
            --success: #00D26A;
            --true-trajectory: #FF6B6B;
            --gps-measurements: #4ECDC4;
            --kalman-estimate: #45B7D1;
            --ellipses: #96CEB4;
            --velocity-vectors: #FFEAA7;
            --accent-light: #6BB6FF;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background);
            color: var(--text);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            color: var(--accent);
            font-size: 28px;
            margin: 0;
            padding: 10px 0;
        }

        .help-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-weight: bold;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 15px;
            margin-bottom: 20px;
        }

        .graph-container {
            background-color: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .graph-help {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-graph {
            grid-column: 1 / 3;
            grid-row: 1 / 3;
            height: 600px;
        }

        .small-graph {
            height: 280px;
        }

        .controls-panel {
            background-color: var(--panel);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
        }

        .control-group {
            background-color: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 10px;
            position: relative;
        }

        .control-help {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-title {
            font-size: 14px;
            color: var(--text);
            margin-bottom: 8px;
            text-align: center;
            font-weight: bold;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            font-size: 12px;
            color: var(--text);
            text-align: center;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--accent-light);
        }

        .reset-button {
            background-color: var(--error);
        }

        .reset-button:hover {
            background-color: #ff6b6b;
        }

        .radio-group, .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-option, .checkbox-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="radio"], input[type="checkbox"] {
            margin: 0;
        }

        label {
            font-size: 12px;
            color: var(--text);
        }

        .info-panel {
            background-color: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
        }

        .info-title {
            font-size: 16px;
            color: var(--accent);
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .info-content {
            font-size: 12px;
            line-height: 1.6;
            color: var(--text);
        }

        .plotly-graph-div {
            width: 100%;
            height: 100%;
        }

        /* Styles pour les popups */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .popup-overlay.active {
            visibility: visible;
            opacity: 1;
        }

        .popup {
            background-color: var(--card);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .popup-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            color: var(--text);
            cursor: pointer;
        }

        .popup-title {
            color: var(--accent);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .popup-content {
            color: var(--text);
            line-height: 1.6;
        }

        .popup-content ul {
            padding-left: 20px;
        }

        .popup-content li {
            margin-bottom: 8px;
        }

        .highlight {
            background-color: rgba(74, 158, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }

        .concept-box {
            background-color: var(--panel);
            border-left: 4px solid var(--accent);
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FILTRE DE KALMAN AVANCÉ - SUIVI DE DRONE</h1>
            <button class="help-button" id="help-main">?</button>
        </header>

        <div class="dashboard">
            <div class="graph-container main-graph" id="trajectory-plot">
                <button class="graph-help" id="help-trajectory">?</button>
            </div>
            <div class="graph-container small-graph" id="error-plot">
                <button class="graph-help" id="help-error">?</button>
            </div>
            <div class="graph-container small-graph" id="uncertainty-plot">
                <button class="graph-help" id="help-uncertainty">?</button>
            </div>
            <div class="graph-container small-graph" id="gain-plot">
                <button class="graph-help" id="help-gain">?</button>
            </div>
            <div class="graph-container small-graph" id="innovation-plot">
                <button class="graph-help" id="help-innovation">?</button>
            </div>
            <div class="graph-container" id="info-panel">
                <div class="info-title">STATISTIQUES</div>
                <div class="info-content" id="stats-info"></div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="controls-grid">
                <!-- Ligne 1: Sliders principaux -->
                <div class="control-group">
                    <button class="control-help" id="help-R">?</button>
                    <div class="control-title">Bruit Mesure (R)</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.1</span>
                            <span>10.0</span>
                        </div>
                        <input type="range" id="R_val" min="0.1" max="10.0" step="0.1" value="2.0">
                        <div class="slider-value" id="R_val-value">2.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-Qpos">?</button>
                    <div class="control-title">Bruit Position (Q)</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.001</span>
                            <span>5.0</span>
                        </div>
                        <input type="range" id="Q_pos_val" min="0.001" max="5.0" step="0.01" value="0.01">
                        <div class="slider-value" id="Q_pos_val-value">0.01</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-Qvel">?</button>
                    <div class="control-title">Bruit Vitesse (Qv)</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.001</span>
                            <span>5.0</span>
                        </div>
                        <input type="range" id="Q_vel_val" min="0.001" max="5.0" step="0.01" value="0.01">
                        <div class="slider-value" id="Q_vel_val-value">0.01</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-uncertainty">?</button>
                    <div class="control-title">Incertitude Initiale</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>10</span>
                            <span>2000</span>
                        </div>
                        <input type="range" id="initial_uncertainty" min="10" max="2000" step="10" value="500">
                        <div class="slider-value" id="initial_uncertainty-value">500</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-acceleration">?</button>
                    <div class="control-title">Facteur Accélération</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.5</span>
                            <span>3.0</span>
                        </div>
                        <input type="range" id="acceleration_factor" min="0.5" max="3.0" step="0.1" value="1.0">
                        <div class="slider-value" id="acceleration_factor-value">1.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-fading">?</button>
                    <div class="control-title">Facteur d'Oubli</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.8</span>
                            <span>1.0</span>
                        </div>
                        <input type="range" id="fading_memory" min="0.8" max="1.0" step="0.01" value="1.0">
                        <div class="slider-value" id="fading_memory-value">1.0</div>
                    </div>
                </div>

                <!-- Ligne 2: Sliders secondaires -->
                <div class="control-group">
                    <button class="control-help" id="help-motion-noise">?</button>
                    <div class="control-title">Bruit Mouvement</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0.0</span>
                            <span>2.0</span>
                        </div>
                        <input type="range" id="motion_noise" min="0.0" max="2.0" step="0.1" value="0.0">
                        <div class="slider-value" id="motion_noise-value">0.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-outlier">?</button>
                    <div class="control-title">Magnitude Outliers</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0</span>
                            <span>50</span>
                        </div>
                        <input type="range" id="outlier_magnitude" min="0" max="50" step="1" value="20">
                        <div class="slider-value" id="outlier_magnitude-value">20</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-dropout-start">?</button>
                    <div class="control-title">Début Dropout</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0</span>
                            <span>49</span>
                        </div>
                        <input type="range" id="dropout_start" min="0" max="49" step="1" value="20">
                        <div class="slider-value" id="dropout_start-value">20</div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-dropout-end">?</button>
                    <div class="control-title">Fin Dropout</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>0</span>
                            <span>49</span>
                        </div>
                        <input type="range" id="dropout_end" min="0" max="49" step="1" value="30">
                        <div class="slider-value" id="dropout_end-value">30</div>
                    </div>
                </div>

                <!-- Ligne 3: Boutons et options -->
                <div class="control-group">
                    <div class="control-title">Actions</div>
                    <div class="button-group">
                        <button id="reset-button" class="reset-button">RESET</button>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-motion-type">?</button>
                    <div class="control-title">Type de Mouvement</div>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="motion-straight" name="motion-type" value="straight" checked>
                            <label for="motion-straight">Droit</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="motion-circular" name="motion-type" value="circular">
                            <label for="motion-circular">Circulaire</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="motion-random" name="motion-type" value="random">
                            <label for="motion-random">Aléatoire</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="motion-accelerating" name="motion-type" value="accelerating">
                            <label for="motion-accelerating">Accélérant</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <button class="control-help" id="help-options">?</button>
                    <div class="control-title">Options Avancées</div>
                    <div class="checkbox-group">
                        <div class="checkbox-option">
                            <input type="checkbox" id="show-ellipses">
                            <label for="show-ellipses">Ellipses</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="show-velocity">
                            <label for="show-velocity">Vitesse</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="adaptive-R">
                            <label for="adaptive-R">R Adaptatif</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="multipath-effect">
                            <label for="multipath-effect">Multitrajets</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popups d'aide -->
    <div class="popup-overlay" id="popup-overlay">
        <div class="popup">
            <button class="popup-close" id="popup-close">&times;</button>
            <h2 class="popup-title" id="popup-title">Titre de la popup</h2>
            <div class="popup-content" id="popup-content">
                Contenu de la popup
            </div>
        </div>
    </div>

    <script>
        // Configuration des couleurs
        const colors = {
            background: '#0A0E1A',
            panel: '#1A1F2E',
            card: '#232938',
            border: '#374151',
            grid: '#2D3748',
            text: '#E8EAED',
            text_secondary: '#9AA0A6',
            accent: '#4A9EFF',
            warning: '#FFB020',
            error: '#FF4757',
            success: '#00D26A',
            true_trajectory: '#FF6B6B',
            gps_measurements: '#4ECDC4',
            kalman_estimate: '#45B7D1',
            ellipses: '#96CEB4',
            velocity_vectors: '#FFEAA7',
            accent_light: '#6BB6FF'
        };

        // Paramètres par défaut
        let params = {
            T: 50,
            motion_type: 'straight',
            motion_noise: 0.0,
            acceleration_factor: 1.0,
            R_val: 2.0,
            Q_pos_val: 0.01,
            Q_vel_val: 0.01,
            dropout_start: 20,
            dropout_end: 30,
            outlier_indices: [10],
            outlier_magnitude: 20.0,
            initial_uncertainty: 500.0,
            fading_memory: 1.0,
            adaptive_R: false,
            multipath_effect: false,
            show_ellipses: false,
            show_velocity: false
        };

        // Données de simulation
        let true_path, gps, kalman, P_list, K_list, innovations;

        // Contenu des popups d'aide
        const helpContent = {
            main: {
                title: "Bienvenue dans le simulateur de Filtre de Kalman",
                content: `
                    <p>Cette application vous permet de visualiser et comprendre le fonctionnement du filtre de Kalman pour le suivi de drone.</p>
                    
                    <div class="concept-box">
                        <strong>Qu'est-ce que le filtre de Kalman?</strong>
                        <p>Le filtre de Kalman est un algorithme qui permet de combiner des mesures bruitées avec un modèle de prédiction pour obtenir une estimation optimale de l'état d'un système.</p>
                    </div>
                    
                    <p><span class="highlight">Comment utiliser cette application:</span></p>
                    <ul>
                        <li>Utilisez les sliders pour ajuster les paramètres du filtre</li>
                        <li>Choisissez le type de mouvement du drone</li>
                        <li>Activez les options avancées pour voir des effets spécifiques</li>
                        <li>Cliquez sur les boutons <span class="highlight">?</span> pour obtenir des explications détaillées</li>
                    </ul>
                    
                    <p>Observez comment la ligne bleue (estimation Kalman) est plus proche de la rouge (trajectoire réelle) que les points verts (mesures GPS bruitées).</p>
                `
            },
            trajectory: {
                title: "Graphique de Trajectoire",
                content: `
                    <p>Ce graphique montre trois éléments importants:</p>
                    
                    <ul>
                        <li><span style="color: ${colors.true_trajectory}">Ligne rouge</span>: La trajectoire réelle du drone (que nous cherchons à estimer)</li>
                        <li><span style="color: ${colors.gps_measurements}">Points turquoise</span>: Les mesures GPS bruyantes (observations)</li>
                        <li><span style="color: ${colors.kalman_estimate}">Ligne bleue</span>: L'estimation du filtre de Kalman (notre meilleure estimation)</li>
                    </ul>
                    
                    <div class="concept-box">
                        <strong>Pourquoi le filtre de Kalman est-il utile?</strong>
                        <p>Les mesures GPS sont bruyantes et parfois manquantes. Le filtre de Kalman combine ces mesures avec un modèle de mouvement pour produire une estimation plus précise et plus lisse de la position réelle.</p>
                    </div>
                    
                    <p><span class="highlight">Expérience à tryer:</span> Augmentez le "Bruit Mesure (R)" et observez comment les mesures deviennent plus erratiques, mais l'estimation Kalman reste stable.</p>
                `
            },
            error: {
                title: "Graphique d'Erreur",
                content: `
                    <p>Ce graphique montre l'erreur entre la position estimée et la position réelle.</p>
                    
                    <div class="concept-box">
                        <strong>L'erreur quadratique moyenne (RMSE)</strong>
                        <p>Cette métrique mesure la precision de l'estimation. Une valeur plus basse indique une meilleure performance du filtre.</p>
                    </div>
                    
                    <p>L'erreur tend à diminuer avec le temps car le filtre "apprend" à mieux estimer l'état du système.</p>
                    
                    <p><span class="highlight">Observation intéressante:</span> Pendant les périodes de dropout (perte de signal GPS), l'erreur peut augmenter car le filtre ne reçoit plus de mesures pour corriger sa prédiction.</p>
                `
            },
            uncertainty: {
                title: "Graphique d'Incertitude",
                content: `
                    <p>Ce graphique montre l'incertitude de l'estimation, représentée par la trace de la matrice de covariance.</p>
                    
                    <div class="concept-box">
                        <strong>La matrice de covariance</strong>
                        <p>Cette matrice représente la confiance du filtre dans son estimation. Une trace plus petite indique une plus grande confiance.</p>
                    </div>
                    
                    <p>L'incertitude diminue généralement avec le temps à mesure que le filtre accumule plus de mesures.</p>
                    
                    <p><span class="highlight">Phénomène observable:</span> Pendant les dropout GPS, l'incertitude augmente car le filtre ne peut pas mettre à jour son estimation avec de nouvelles mesures.</p>
                `
            },
            gain: {
                title: "Graphique de Gain de Kalman",
                content: `
                    <p>Ce graphique montre la norme du gain de Kalman, qui représente la confiance relative accordée aux mesures par rapport au modèle.</p>
                    
                    <div class="concept-box">
                        <strong>Le gain de Kalman</strong>
                        <p>Le gain détermine à quel point le filtre doit ajuster son estimation basée sur la nouvelle mesure. Un gain élevé signifie que le filtre fait plus confiance aux mesures.</p>
                    </div>
                    
                    <p>Le gain tend à diminuer avec le temps à mesure que le filtre devient plus confiant dans son estimation.</p>
                    
                    <p><span class="highlight">À noter:</span> Lorsque le "Bruit Mesure (R)" est faible, le gain est plus élevé car les mesures sont considérées comme plus fiables.</p>
                `
            },
            innovation: {
                title: "Graphique d'Innovations",
                content: `
                    <p>Ce graphique montre les innovations, c'est-à-dire la différence entre les mesures et ce que le filtre avait prédit.</p>
                    
                    <div class="concept-box">
                        <strong>Les innovations</strong>
                        <p>Les innovations représentent l'information nouvelle apportée par chaque mesure. Si le filtre fonctionne correctement, les innovations devraient avoir une moyenne nulle.</p>
                    </div>
                    
                    <p>La ligne pointillée rouge représente le seuil de 2σ (deux écarts-types). Si une innovation dépasse ce seuil, cela peut indiquer une mesure aberrante.</p>
                    
                    <p><span class="highlight">Utilisation pratique:</span> En mode "R Adaptatif", le filtre détecte les innovations importantes et réduit sa confiance dans les mesures (augmente R) pour se protéger contre les outliers.</p>
                `
            },
            R: {
                title: "Bruit de Mesure (R)",
                content: `
                    <p>Ce paramètre représente l'incertitude des mesures GPS.</p>
                    
                    <div class="concept-box">
                        <strong>La matrice R</strong>
                        <p>Dans le filtre de Kalman, R représente la covariance du bruit de mesure. Une valeur élevée de R signifie que les mesures sont très bruyantes.</p>
                    </div>
                    
                    <p><span class="highlight">Effet:</span> Lorsque R est élevé, le filtre fait moins confiance aux mesures et se fie davantage à son modèle de prédiction.</p>
                    
                    <p><span class="highlight">Expérience:</span> Augmentez R et observez comment l'estimation devient plus lisse mais peut être moins réactive aux changements brusques.</p>
                `
            },
            Qpos: {
                title: "Bruit de Position (Q)",
                content: `
                    <p>Ce paramètre représente l'incertitude du modèle de position.</p>
                    
                    <div class="concept-box">
                        <strong>La matrice Q</strong>
                        <p>Dans le filtre de Kalman, Q représente la covariance du bruit de processus. Une valeur élevée de Q signifie que le modèle de mouvement est incertain.</p>
                    </div>
                    
                    <p><span class="highlight">Effet:</span> Lorsque Q est élevé, le filtre fait moins confiance à son modèle et se fie davantage aux mesures.</p>
                    
                    <p><span class="highlight">Expérience:</span> Augmentez Q et observez comment l'estimation devient plus réactive aux mesures mais aussi plus bruyante.</p>
                `
            },
            Qvel: {
                title: "Bruit de Vitesse (Qv)",
                content: `
                    <p>Ce paramètre représente l'incertitude du modèle de vitesse.</p>
                    
                    <div class="concept-box">
                        <strong>Le modèle de vitesse</strong>
                        <p>Le filtre de Kalman utilise un modèle qui prédit à la fois la position et la vitesse. Qv contrôle l'incertitude sur la composante vitesse.</p>
                    </div>
                    
                    <p><span class="highlight">Effet:</span> Lorsque Qv est élevé, le filtre permet des changements de vitesse plus importants et imprévus.</p>
                    
                    <p><span class="highlight">Expérience:</span> Augmentez Qv et observez comment l'estimation devient plus flexible pour suivre des changements de direction brusques.</p>
                `
            },
            // ... autres contenus d'aide pour les paramètres
        };

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            // Initialiser les écouteurs d'événements pour les sliders
            initSliders();
            
            // Initialiser les écouteurs d'événements pour les boutons
            document.getElementById('reset-button').addEventListener('click', resetAll);
            
            // Initialiser les écouteurs pour les radios et checkboxes
            document.querySelectorAll('input[name="motion-type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    params.motion_type = this.value;
                    runSimulation();
                });
            });
            
            document.getElementById('show-ellipses').addEventListener('change', function() {
                params.show_ellipses = this.checked;
                runSimulation();
            });
            
            document.getElementById('show-velocity').addEventListener('change', function() {
                params.show_velocity = this.checked;
                runSimulation();
            });
            
            document.getElementById('adaptive-R').addEventListener('change', function() {
                params.adaptive_R = this.checked;
                runSimulation();
            });
            
            document.getElementById('multipath-effect').addEventListener('change', function() {
                params.multipath_effect = this.checked;
                runSimulation();
            });
            
            // Initialiser les popups d'aide
            initHelpPopups();
            
            // Exécuter la simulation initiale
            runSimulation();
        });

        // Initialiser les popups d'aide
        function initHelpPopups() {
            const popupOverlay = document.getElementById('popup-overlay');
            const popupClose = document.getElementById('popup-close');
            const popupTitle = document.getElementById('popup-title');
            const popupContent = document.getElementById('popup-content');
            
            // Fermer la popup
            popupClose.addEventListener('click', function() {
                popupOverlay.classList.remove('active');
            });
            
            // Fermer en cliquant à l'extérieur
            popupOverlay.addEventListener('click', function(e) {
                if (e.target === popupOverlay) {
                    popupOverlay.classList.remove('active');
                }
            });
            
            // Ouvrir les popups d'aide
            document.querySelectorAll('.help-button, .graph-help, .control-help').forEach(button => {
                button.addEventListener('click', function() {
                    const helpId = this.id.replace('help-', '');
                    if (helpContent[helpId]) {
                        popupTitle.textContent = helpContent[helpId].title;
                        popupContent.innerHTML = helpContent[helpId].content;
                        popupOverlay.classList.add('active');
                    }
                });
            });
        }

        // Initialiser les écouteurs pour les sliders
        function initSliders() {
            const sliders = [
                'R_val', 'Q_pos_val', 'Q_vel_val', 'initial_uncertainty', 'acceleration_factor', 'fading_memory',
                'motion_noise', 'outlier_magnitude', 'dropout_start', 'dropout_end'
            ];
            
            sliders.forEach(param => {
                const slider = document.getElementById(param);
                const valueDisplay = document.getElementById(`${param}-value`);
                
                // Mettre à jour l'affichage de la valeur
                valueDisplay.textContent = slider.value;
                params[param] = parseFloat(slider.value);
                
                // Ajouter l'écouteur d'événement
                slider.addEventListener('input', function() {
                    valueDisplay.textContent = this.value;
                    params[param] = parseFloat(this.value);
                    runSimulation();
                });
            });
        }

        // Réinitialiser tous les paramètres
        function resetAll() {
            // Réinitialiser les sliders
            document.getElementById('R_val').value = 2.0;
            document.getElementById('R_val-value').textContent = '2.0';
            params.R_val = 2.0;
            
            document.getElementById('Q_pos_val').value = 0.01;
            document.getElementById('Q_pos_val-value').textContent = '0.01';
            params.Q_pos_val = 0.01;
            
            document.getElementById('Q_vel_val').value = 0.01;
            document.getElementById('Q_vel_val-value').textContent = '0.01';
            params.Q_vel_val = 0.01;
            
            document.getElementById('initial_uncertainty').value = 500;
            document.getElementById('initial_uncertainty-value').textContent = '500';
            params.initial_uncertainty = 500;
            
            document.getElementById('acceleration_factor').value = 1.0;
            document.getElementById('acceleration_factor-value').textContent = '1.0';
            params.acceleration_factor = 1.0;
            
            document.getElementById('fading_memory').value = 1.0;
            document.getElementById('fading_memory-value').textContent = '1.0';
            params.fading_memory = 1.0;
            
            document.getElementById('motion_noise').value = 0.0;
            document.getElementById('motion_noise-value').textContent = '0.0';
            params.motion_noise = 0.0;
            
            document.getElementById('outlier_magnitude').value = 20;
            document.getElementById('outlier_magnitude-value').textContent = '20';
            params.outlier_magnitude = 20;
            
            document.getElementById('dropout_start').value = 20;
            document.getElementById('dropout_start-value').textContent = '20';
            params.dropout_start = 20;
            
            document.getElementById('dropout_end').value = 30;
            document.getElementById('dropout_end-value').textContent = '30';
            params.dropout_end = 30;
            
            // Réinitialiser les radios
            document.getElementById('motion-straight').checked = true;
            params.motion_type = 'straight';
            
            // Réinitialiser les checkboxes
            document.getElementById('show-ellipses').checked = false;
            params.show_ellipses = false;
            
            document.getElementById('show-velocity').checked = false;
            params.show_velocity = false;
            
            document.getElementById('adaptive-R').checked = false;
            params.adaptive_R = false;
            
            document.getElementById('multipath-effect').checked = false;
            params.multipath_effect = false;
            
            // Relancer la simulation
            runSimulation();
        }

        // ... (le reste du code reste inchangé, seules les fonctions d'initialisation des popups ont été ajoutées)
        
        // Simuler la trajectoire réelle
        function simulateTruePath(T, motion_type, motion_noise, acceleration_factor) {
            // Utiliser une graine fixe pour la reproductibilité
            Math.seedrandom('42');
            
            let x = new Array(T);
            let y = new Array(T);
            
            if (motion_type === 'straight') {
                for (let i = 0; i < T; i++) {
                    x[i] = (i > 0 ? x[i-1] : 0) + (1 + gaussianRandom(0, motion_noise)) * acceleration_factor;
                    y[i] = (i > 0 ? y[i-1] : 0) + (0.5 + gaussianRandom(0, motion_noise)) * acceleration_factor;
                }
            } else if (motion_type === 'circular') {
                for (let i = 0; i < T; i++) {
                    const t = 4 * Math.PI * i / T;
                    x[i] = 10 * Math.cos(t * acceleration_factor) + gaussianRandom(0, motion_noise);
                    y[i] = 10 * Math.sin(t * acceleration_factor) + gaussianRandom(0, motion_noise);
                }
            } else if (motion_type === 'random') {
                for (let i = 0; i < T; i++) {
                    x[i] = (i > 0 ? x[i-1] : 0) + gaussianRandom(1, 0.5) * acceleration_factor + gaussianRandom(0, motion_noise);
                    y[i] = (i > 0 ? y[i-1] : 0) + gaussianRandom(0.5, 0.3) * acceleration_factor + gaussianRandom(0, motion_noise);
                }
            } else { // accelerating
                for (let i = 0; i < T; i++) {
                    const a = 0.1 * acceleration_factor;
                    x[i] = 0.5 * a * i * i + gaussianRandom(0, motion_noise);
                    y[i] = 0.3 * a * i * i + gaussianRandom(0, motion_noise);
                }
            }
            
            return {x, y};
        }

        // Simuler les mesures GPS
        function simulateGPSMeasurements(true_path, R_val, dropout_start, dropout_end, outlier_indices, outlier_magnitude, multipath_effect) {
            const T = true_path.x.length;
            let gps_x = new Array(T);
            let gps_y = new Array(T);
            
            let mp_x = 0, mp_y = 0;
            
            for (let i = 0; i < T; i++) {
                // Effet multitrajets
                if (multipath_effect) {
                    mp_x = 0.7 * mp_x + gaussianRandom(0, R_val/2);
                    mp_y = 0.7 * mp_y + gaussianRandom(0, R_val/2);
                }
                
                // Valeur de base avec bruit
                gps_x[i] = true_path.x[i] + gaussianRandom(0, R_val) + (multipath_effect ? mp_x : 0);
                gps_y[i] = true_path.y[i] + gaussianRandom(0, R_val) + (multipath_effect ? mp_y : 0);
                
                // Dropout
                if (i >= dropout_start && i < dropout_end) {
                    gps_x[i] = NaN;
                    gps_y[i] = NaN;
                }
                
                // Outliers
                if (outlier_indices.includes(i)) {
                    gps_x[i] += (Math.random() > 0.5 ? 1 : -1) * outlier_magnitude;
                    gps_y[i] += (Math.random() > 0.5 ? 1 : -1) * outlier_magnitude;
                }
            }
            
            return {x: gps_x, y: gps_y};
        }

        // Implémentation du filtre de Kalman
        function kalmanFilter(zs_x, zs_y, R, Q_pos, Q_vel, initial_velocity, initial_uncertainty, adaptive_R, fading_memory) {
            const n = zs_x.length;
            
            // Trouver la première mesure valide
            let first = 0;
            while (first < n && (isNaN(zs_x[first]) || isNaN(zs_y[first]))) {
                first++;
            }
            
            if (first === n) {
                throw new Error("Aucune mesure valide pour initialiser le filtre.");
            }
            
            // État initial [x, y, vx, vy]
            let x = [zs_x[first], zs_y[first], initial_velocity[0], initial_velocity[1]];
            let P = numeric.identity(4).map(row => row.map(val => val * initial_uncertainty));
            
            const dt = 1.0;
            const F = [
                [1, 0, dt, 0],
                [0, 1, 0, dt],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];
            
            const H = [
                [1, 0, 0, 0],
                [0, 1, 0, 0]
            ];
            
            const Q = numeric.diag([Q_pos, Q_pos, Q_vel, Q_vel]);
            
            let results = [];
            let Ps = [];
            let Ks = [];
            let innovations = [];
            
            let R_cur = R;
            
            for (let i = 0; i < n; i++) {
                // Prédiction
                x = numeric.dot(F, x);
                P = numeric.dot(numeric.dot(F, P), numeric.transpose(F));
                P = numeric.add(P, Q);
                P = numeric.mul(P, fading_memory);
                
                if (isNaN(zs_x[i]) || isNaN(zs_y[i])) {
                    results.push([...x]);
                    Ps.push([...P.map(row => [...row])]);
                    Ks.push(numeric.rep([4, 2], 0));
                    innovations.push([0, 0]);
                    continue;
                }
                
                const z = [zs_x[i], zs_y[i]];
                
                // Innovation
                const Hx = numeric.dot(H, x);
                const y = [z[0] - Hx[0], z[1] - Hx[1]];
                innovations.push([...y]);
                
                if (adaptive_R && i > 0) {
                    const r0 = 2 * Math.sqrt(R);
                    R_cur = numeric.norm2(y) > r0 ? R * 5 : R;
                }
                
                const S = numeric.add(numeric.dot(numeric.dot(H, P), numeric.transpose(H)), numeric.mul(R_cur, numeric.identity(2)));
                const K = numeric.dot(numeric.dot(P, numeric.transpose(H)), numeric.inv(S));
                
                // Mise à jour
                x = numeric.add(x, numeric.dot(K, y));
                const I = numeric.identity(4);
                P = numeric.dot(numeric.sub(I, numeric.dot(K, H)), P);
                
                results.push([...x]);
                Ps.push([...P.map(row => [...row])]);
                Ks.push([...K.map(row => [...row])]);
            }
            
            return {
                results: results,
                Ps: Ps,
                Ks: Ks,
                innovations: innovations
            };
        }

        // Générer un nombre aléatoire avec distribution gaussienne
        function gaussianRandom(mean = 0, stdev = 1) {
            const u = 1 - Math.random();
            const v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * stdev + mean;
        }

        // Exécuter la simulation complète
        function runSimulation() {
            // Simuler la trajectoire réelle
            const truePath = simulateTruePath(
                params.T, 
                params.motion_type, 
                params.motion_noise, 
                params.acceleration_factor
            );
            
            // Simuler les mesures GPS
            const gpsData = simulateGPSMeasurements(
                truePath, 
                params.R_val,
                params.dropout_start,
                params.dropout_end,
                params.outlier_indices,
                params.outlier_magnitude,
                params.multipath_effect
            );
            
            // Appliquer le filtre de Kalman
            const kalmanResult = kalmanFilter(
                gpsData.x,
                gpsData.y,
                params.R_val,
                params.Q_pos_val,
                params.Q_vel_val,
                [1, 1],  // Vitesse initiale
                params.initial_uncertainty,
                params.adaptive_R,
                params.fading_memory
            );
            
            // Stocker les résultats
            true_path = truePath;
            gps = gpsData;
            kalman = kalmanResult.results;
            P_list = kalmanResult.Ps;
            K_list = kalmanResult.Ks;
            innovations = kalmanResult.innovations;
            
            // Mettre à jour les visualisations
            updatePlots();
        }

        // Mettre à jour tous les graphiques
        function updatePlots() {
            updateTrajectoryPlot();
            updateErrorPlot();
            updateUncertaintyPlot();
            updateGainPlot();
            updateInnovationPlot();
            updateStatsPanel();
        }

        // Mettre à jour le graphique de trajectoire
        function updateTrajectoryPlot() {
            const time = Array.from({length: params.T}, (_, i) => i);
            
            // Préparer les données pour Plotly
            const trueTrajectory = {
                x: true_path.x,
                y: true_path.y,
                mode: 'lines',
                name: 'Trajectoire réelle',
                line: { color: colors.true_trajectory, width: 3 },
                hovertemplate: 'X: %{x:.2f}<br>Y: %{y:.2f}<extra></extra>'
            };
            
            // Filtrer les points GPS valides
            const validGPS = gps.x.map((x, i) => isNaN(x) ? null : x);
            const validGPSy = gps.y.map((y, i) => isNaN(y) ? null : y);
            
            const gpsMeasurements = {
                x: validGPS,
                y: validGPSy,
                mode: 'markers',
                name: 'Mesures GPS',
                marker: {
                    color: colors.gps_measurements,
                    size: 8,
                    line: { color: 'white', width: 1 }
                },
                hovertemplate: 'X: %{x:.2f}<br>Y: %{y:.2f}<extra></extra>'
            };
            
            const kalmanEstimate = {
                x: kalman.map(point => point[0]),
                y: kalman.map(point => point[1]),
                mode: 'lines',
                name: 'Estimation Kalman',
                line: { color: colors.kalman_estimate, width: 3.5 },
                hovertemplate: 'X: %{x:.2f}<br>Y: %{y:.2f}<extra></extra>'
            };
            
            const data = [trueTrajectory, gpsMeasurements, kalmanEstimate];
            
            // Ajouter des ellipses de confiance si activé
            if (params.show_ellipses) {
                const step = Math.max(1, Math.floor(params.T / 10));
                for (let i = 0; i < params.T; i += step) {
                    if (i < P_list.length) {
                        const cov = P_list[i].slice(0, 2).map(row => row.slice(0, 2));
                        const ellipse = drawEllipse(
                            kalman[i][0], 
                            kalman[i][1], 
                            cov, 
                            2.0, 
                            colors.ellipses
                        );
                        data.push(ellipse);
                    }
                }
            }
            
            // Ajouter des vecteurs vitesse si activé
            if (params.show_velocity) {
                const step = Math.max(1, Math.floor(params.T / 8));
                for (let i = 0; i < params.T; i += step) {
                    const vx = kalman[i][2];
                    const vy = kalman[i][3];
                    
                    const arrow = {
                        type: 'scatter',
                        x: [kalman[i][0], kalman[i][0] + 2 * vx],
                        y: [kalman[i][1], kalman[i][1] + 2 * vy],
                        mode: 'lines',
                        line: { color: colors.velocity_vectors, width: 2 },
                        showlegend: false,
                        hoverinfo: 'skip'
                    };
                    
                    data.push(arrow);
                    
                    // Ajouter la tête de flèche
                    const arrowHead = {
                        x: [kalman[i][0] + 2 * vx],
                        y: [kalman[i][1] + 2 * vy],
                        mode: 'markers',
                        marker: {
                            color: colors.velocity_vectors,
                            size: 8,
                            symbol: 'triangle-up'
                        },
                        showlegend: false,
                        hoverinfo: 'skip'
                    };
                    
                    data.push(arrowHead);
                }
            }
            
            // Mise en page
            const layout = {
                title: 'TRAJECTOIRE & ESTIMATION',
                xaxis: { title: 'Position X (m)', gridcolor: colors.grid, zerolinecolor: colors.grid },
                yaxis: { title: 'Position Y (m)', gridcolor: colors.grid, zerolinecolor: colors.grid },
                plot_bgcolor: colors.card,
                paper_bgcolor: colors.panel,
                font: { color: colors.text },
                legend: { 
                    x: 0, 
                    y: 1,
                    bgcolor: colors.card,
                    bordercolor: colors.border,
                    borderwidth: 1
                },
                hovermode: 'closest'
            };
            
            Plotly.react('trajectory-plot', data, layout);
        }

        // Dessiner une ellipse de confiance
        function drawEllipse(x, y, cov, n_std, color) {
            // Calculer les valeurs propres et vecteurs propres
            const a = cov[0][0];
            const b = cov[0][1];
            const c = cov[1][1];
            
            const lambda1 = (a + c) / 2 + Math.sqrt(Math.pow((a - c) / 2, 2) + Math.pow(b, 2));
            const lambda2 = (a + c) / 2 - Math.sqrt(Math.pow((a - c) / 2, 2) + Math.pow(b, 2));
            
            const width = 2 * n_std * Math.sqrt(lambda1);
            const height = 2 * n_std * Math.sqrt(lambda2);
            
            let angle = 0;
            if (b !== 0) {
                angle = Math.atan2(lambda1 - a, b) * 180 / Math.PI;
            }
            
            // Générer les points de l'ellipse
            const t = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 99);
            const ellipseX = t.map(theta => x + width/2 * Math.cos(theta) * Math.cos(angle) - height/2 * Math.sin(theta) * Math.sin(angle));
            const ellipseY = t.map(theta => y + width/2 * Math.cos(theta) * Math.sin(angle) + height/2 * Math.sin(theta) * Math.cos(angle));
            
            return {
                x: ellipseX,
                y: ellipseY,
                mode: 'lines',
                line: { color: color, width: 1.8 },
                fill: 'none',
                showlegend: false,
                hoverinfo: 'skip'
            };
        }

        // Mettre à jour le graphique d'erreur
        function updateErrorPlot() {
            const time = Array.from({length: params.T}, (_, i) => i);
            
            // Calculer l'erreur
            const error = time.map(i => {
                const dx = true_path.x[i] - kalman[i][0];
                const dy = true_path.y[i] - kalman[i][1];
                return Math.sqrt(dx*dx + dy*dy);
            });
            
            const errorTrace = {
                x: time,
                y: error,
                mode: 'lines',
                name: 'Erreur',
                line: { color: colors.error, width: 2 },
                fill: 'tozeroy',
                fillcolor: `rgba(${hexToRgb(colors.error).r}, ${hexToRgb(colors.error).g}, ${hexToRgb(colors.error).b}, 0.25)`
            };
            
            const layout = {
                title: 'ERREUR POSITION',
                xaxis: { title: 'Temps', gridcolor: colors.grid, zerolinecolor: colors.grid },
                yaxis: { title: 'Erreur (m)', gridcolor: colors.grid, zerolinecolor: colors.grid },
                plot_bgcolor: colors.card,
                paper_bgcolor: colors.panel,
                font: { color: colors.text },
                showlegend: false
            };
            
            Plotly.react('error-plot', [errorTrace], layout);
        }

        // Mettre à jour le graphique d'incertitude
        function updateUncertaintyPlot() {
            const time = Array.from({length: params.T}, (_, i) => i);
            
            // Calculer la trace de la matrice de covariance (position seulement)
            const traceP = P_list.map(P => P[0][0] + P[1][1]);
            
            const uncertaintyTrace = {
                x: time,
                y: traceP,
                mode: 'lines',
                name: 'Incertitude',
                line: { color: colors.warning, width: 2 },
                fill: 'tozeroy',
                fillcolor: `rgba(${hexToRgb(colors.warning).r}, ${hexToRgb(colors.warning).g}, ${hexToRgb(colors.warning).b}, 0.25)`
            };
            
            const layout = {
                title: 'INCERTITUDE',
                xaxis: { title: 'Temps', gridcolor: colors.grid, zerolinecolor: colors.grid },
                yaxis: { title: 'Trace(P)', gridcolor: colors.grid, zerolinecolor: colors.grid },
                plot_bgcolor: colors.card,
                paper_bgcolor: colors.panel,
                font: { color: colors.text },
                showlegend: false
            };
            
            Plotly.react('uncertainty-plot', [uncertaintyTrace], layout);
        }

        // Mettre à jour le graphique de gain de Kalman
        function updateGainPlot() {
            const time = Array.from({length: params.T}, (_, i) => i);
            
            // Calculer la norme du gain de Kalman
            const Kmag = K_list.map(K => {
                const k11 = K[0][0], k12 = K[0][1];
                const k21 = K[1][0], k22 = K[1][1];
                const k31 = K[2][0], k32 = K[2][1];
                const k41 = K[3][0], k42 = K[3][1];
                
                return Math.sqrt(k11*k11 + k12*k12 + k21*k21 + k22*k22 + k31*k31 + k32*k32 + k41*k41 + k42*k42);
            });
            
            const gainTrace = {
                x: time,
                y: Kmag,
                mode: 'lines',
                name: 'Gain Kalman',
                line: { color: colors.accent, width: 2 },
                fill: 'tozeroy',
                fillcolor: `rgba(${hexToRgb(colors.accent).r}, ${hexToRgb(colors.accent).g}, ${hexToRgb(colors.accent).b}, 0.25)`
            };
            
            const layout = {
                title: 'GAIN KALMAN',
                xaxis: { title: 'Temps', gridcolor: colors.grid, zerolinecolor: colors.grid },
                yaxis: { title: '||K||', gridcolor: colors.grid, zerolinecolor: colors.grid },
                plot_bgcolor: colors.card,
                paper_bgcolor: colors.panel,
                font: { color: colors.text },
                showlegend: false
            };
            
            Plotly.react('gain-plot', [gainTrace], layout);
        }

        // Mettre à jour le graphique d'innovations
        function updateInnovationPlot() {
            const time = Array.from({length: params.T}, (_, i) => i);
            
            // Calculer la norme des innovations
            const innovMag = innovations.map(inn => Math.sqrt(inn[0]*inn[0] + inn[1]*inn[1]));
            
            const innovationTrace = {
                x: time,
                y: innovMag,
                mode: 'lines',
                name: 'Innovations',
                line: { color: colors.success, width: 2 }
            };
            
            // Seuil 2σ
            const threshold = 2 * Math.sqrt(params.R_val);
            const thresholdTrace = {
                x: [time[0], time[time.length-1]],
                y: [threshold, threshold],
                mode: 'lines',
                name: 'Seuil 2σ',
                line: { color: colors.error, width: 1.8, dash: 'dash' }
            };
            
            const layout = {
                title: 'INNOVATIONS',
                xaxis: { title: 'Temps', gridcolor: colors.grid, zerolinecolor: colors.grid },
                yaxis: { title: '||Innov||', gridcolor: colors.grid, zerolinecolor: colors.grid },
                plot_bgcolor: colors.card,
                paper_bgcolor: colors.panel,
                font: { color: colors.text },
                legend: { 
                    x: 1, 
                    y: 1,
                    bgcolor: colors.card,
                    bordercolor: colors.border,
                    borderwidth: 1,
                    font: { size: 10 }
                }
            };
            
            Plotly.react('innovation-plot', [innovationTrace, thresholdTrace], layout);
        }

        // Mettre à jour le panneau d'information
        function updateStatsPanel() {
            // Calculer les statistiques
            const error = Array.from({length: params.T}, (_, i) => {
                const dx = true_path.x[i] - kalman[i][0];
                const dy = true_path.y[i] - kalman[i][1];
                return Math.sqrt(dx*dx + dy*dy);
            });
            
            const meanError = error.reduce((sum, val) => sum + val, 0) / params.T;
            const maxError = Math.max(...error);
            const minError = Math.min(...error);
            const stdError = Math.sqrt(error.map(e => Math.pow(e - meanError, 2)).reduce((sum, val) => sum + val, 0) / params.T);
            
            const traceP = P_list.map(P => P[0][0] + P[1][1]);
            const meanUncertainty = traceP.reduce((sum, val) => sum + val, 0) / params.T;
            
            const Kmag = K_list.map(K => {
                const k11 = K[0][0], k12 = K[0][1];
                const k21 = K[1][0], k22 = K[1][1];
                const k31 = K[2][0], k32 = K[2][1];
                const k41 = K[3][0], k42 = K[3][1];
                
                return Math.sqrt(k11*k11 + k12*k12 + k21*k21 + k22*k22 + k31*k31 + k32*k32 + k41*k41 + k42*k42);
            });
            const meanGain = Kmag.reduce((sum, val) => sum + val, 0) / params.T;
            
            // Formater le texte
            const statsText = `
                Points: ${params.T}<br>
                Erreur Moyenne: ${meanError.toFixed(2)} m<br>
                Erreur Max: ${maxError.toFixed(2)} m<br>
                Erreur Min: ${minError.toFixed(2)} m<br>
                Écart-type: ${stdError.toFixed(2)} m<br>
                <br>
                Incertitude Moyenne (Trace P_xy): ${meanUncertainty.toFixed(2)}<br>
                Gain Kalman Moyen: ${meanGain.toFixed(3)}<br>
                <br>
                R = ${params.R_val.toFixed(2)}, Qp = ${params.Q_pos_val.toFixed(2)}, Qv = ${params.Q_vel_val.toFixed(2)}<br>
                Dropout: ${params.dropout_start} → ${params.dropout_end}<br>
                Outliers: ${params.outlier_indices.length} (mag = ${params.outlier_magnitude.toFixed(0)})<br>
                Multipath: ${params.multipath_effect ? 'ON' : 'OFF'}<br>
                R adaptatif: ${params.adaptive_R ? 'ON' : 'OFF'}<br>
                Facteur d'oubli: ${params.fading_memory.toFixed(3)}
            `;
            
            document.getElementById('stats-info').innerHTML = statsText;
        }

        // Convertir une couleur hexadécimale en RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Ajouter seedrandom pour la reproductibilité
        Math.seedrandom = function(seed) {
            let x = 0;
            for (let i = 0; i < seed.length; i++) {
                x += seed.charCodeAt(i);
            }
            
            return function() {
                x = Math.sin(x) * 10000;
                return x - Math.floor(x);
            };
        };
    </script>
</body>
</html>